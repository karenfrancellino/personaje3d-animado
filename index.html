<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Droyz AR Character</title>
  <meta name="theme-color" content="#000000">

  <!-- A-Frame 1.6.0 for better WebXR support -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- A-Frame Extras for Animation -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      background-color: #000;
    }

    /* UI Overlay */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      pointer-events: none;
      /* Let clicks pass to scene logic */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    /* Access Denied Overlay */
    #login-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    /* Controls (Photo/Video) */
    .controls {
      pointer-events: auto;
      display: flex;
      justify-content: center;
      gap: 30px;
      padding-bottom: 30px;
    }

    .btn {
      width: 65px;
      height: 65px;
      border-radius: 50%;
      border: 3px solid white;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      color: white;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .btn:active {
      transform: scale(0.9);
      background: rgba(255, 255, 255, 0.4);
    }

    .recording {
      background: rgba(255, 0, 0, 0.8) !important;
      border-color: red !important;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.4);
      }

      70% {
        box-shadow: 0 0 0 15px rgba(255, 0, 0, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
      }
    }

    /* Skin Carousel */
    .skin-carousel {
      pointer-events: auto;
      display: flex;
      overflow-x: auto;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      margin-top: 10px;
      scrollbar-width: none;
      /* Firefox */
    }

    .skin-carousel::-webkit-scrollbar {
      display: none;
    }

    .skin-item {
      min-width: 60px;
      height: 60px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
      cursor: pointer;
    }

    .skin-item.selected {
      border-color: #00e5ff;
      background: rgba(0, 229, 255, 0.2);
    }

    /* Hide Enter AR Button Default Style */
    .a-enter-vr-button {
      bottom: 20px !important;
    }
  </style>

  <script>
    // --- 1. WebXR Hit Test & Reticle Component ---
    AFRAME.registerComponent('ar-hit-test-cursor', {
      init: function () {
        this.reticle = document.querySelector('#reticle');
        this.character = document.querySelector('#personaje');
        this.isVisible = false;

        this.el.sceneEl.addEventListener('enter-vr', () => {
          if (this.el.sceneEl.is('ar-mode')) {
            this.reticle.setAttribute('visible', 'true');
            this.isVisible = true;
          }
        });

        this.el.sceneEl.addEventListener('exit-vr', () => {
          this.reticle.setAttribute('visible', 'false');
          this.isVisible = false;
        });

        this.el.addEventListener('ar-hit-test-select', (evt) => {
          // Place character logic
          const reticlePos = this.reticle.getAttribute('position');
          const reticleRot = this.reticle.getAttribute('rotation');

          this.character.setAttribute('position', reticlePos);
          // Only take Y rotation to face user? Or match reticle?
          // Usually we want character upright. Reticle follows surface normal.
          // Let's just place it. User can rotate manually later if needed.
          this.character.setAttribute('visible', 'true');

          // Optional: Face camera
          const camPos = this.el.sceneEl.camera.el.object3D.position;
          this.character.object3D.lookAt(camPos.x, this.character.object3D.position.y, camPos.z);
        });
      }
    });

    // --- 2. Fallback "Drag to Place" Component (for iOS/Non-WebXR) ---
    AFRAME.registerComponent('drag-place-fallback', {
      init: function () {
        this.el.sceneEl.canvas.addEventListener('click', (evt) => {
          if (!this.el.sceneEl.is('ar-mode')) {
            // Non-WebXR Mode (or iOS Safari without WebXR)
            // Simple casting
            const camera = this.el.sceneEl.camera;
            if (!camera) return;

            // Just place 2 meters in front of camera
            const dir = new THREE.Vector3(0, 0, -2);
            dir.applyQuaternion(camera.quaternion);
            const pos = camera.position.clone().add(dir);

            // Keep floor level relative? 
            const character = document.querySelector('#personaje');
            character.setAttribute('position', `${pos.x} ${pos.y - 0.5} ${pos.z}`);
            character.setAttribute('visible', 'true');
          }
        });
      }
    });
  </script>
</head>

<body>

  <!-- Security Overlay -->
  <div id="login-screen" style="display: none;"> <!-- Default hidden for testing, will enable via JS -->
    <h2>üîí Access Locked</h2>
    <p>Please scan the QR code from the app to unlock this character.</p>
  </div>

  <!-- Main Scene 
       webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #overlay;"
       This enables native Surface Detection on Android Chrome.
  -->
  <a-scene webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #overlay;"
    ar-hit-test="target: #reticle; type: map;" ar-hit-test-cursor drag-place-fallback
    renderer="colorManagement: true; sortObjects: true; highRefreshRate: true;" vr-mode-ui="enabled: true">

    <a-assets>
      <!-- Default Model -->
      <a-asset-item id="model-default"
        src="https://raw.githubusercontent.com/karenfrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb"></a-asset-item>
    </a-assets>

    <!-- Camera -->
    <a-entity camera position="0 1.6 0"
      look-controls="magicWindowTrackingEnabled: false; touchEnabled: false; mouseEnabled: false"></a-entity>

    <!-- Lighting -->
    <a-light type="ambient" intensity="1"></a-light>
    <a-light type="directional" position="1 2 1" intensity="1.5"></a-light>

    <!-- Reticle (Visualizes Surface) -->
    <!-- Simple Ring Geometry -->
    <a-entity id="reticle" visible="false">
      <a-ring color="white" radius-inner="0.05" radius-outer="0.06" rotation="-90 0 0" opacity="0.8"></a-ring>
      <a-circle color="white" radius="0.01" rotation="-90 0 0" opacity="0.8"></a-circle>
    </a-entity>

    <!-- Character 
         Scale: 15cm -> 0.15 
         Hidden until placed 
    -->
    <a-entity id="personaje" gltf-model="#model-default" scale="0.15 0.15 0.15" visible="false"
      animation-mixer="loop: repeat;">
    </a-entity>

  </a-scene>

  <!-- UI Overlay -->
  <div id="overlay">

    <!-- Skin Selector (Example Items) -->
    <div class="skin-carousel" id="skinCarousel">
      <!-- Populated by JS -->
    </div>

    <!-- Capture Controls -->
    <div class="controls">
      <div id="btnFoto" class="btn">üì∏</div>
      <div id="btnVideo" class="btn">üî¥</div>
    </div>
  </div>

  <script>
    /* ----------------------------------------------------------------
       CONFIGURATION & DATA
    ---------------------------------------------------------------- */
    // Example Skins Configuration
    const SKINS = [
      { id: 'sickjacken', name: 'Sick Jacken', url: 'https://raw.githubusercontent.com/karenfrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb' },
      { id: 'skin2', name: 'Skin 2', url: 'https://raw.githubusercontent.com/karenfrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb' }, // Duplicate for demo
      { id: 'skin3', name: 'Skin 3', url: 'https://raw.githubusercontent.com/karenfrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb' },
    ];

    /* ----------------------------------------------------------------
       1. SECURITY / INTEGRATION
    ---------------------------------------------------------------- */
    function checkSecurity() {
      const params = new URLSearchParams(window.location.search);
      const token = params.get('token');
      const skinId = params.get('skin');

      // If required to be locked:
      // if (!token) {
      //   document.getElementById('login-screen').style.display = 'flex';
      //   document.getElementById('overlay').style.display = 'none';
      //   return false;
      // }

      // Select Skin
      if (skinId) {
        selectSkin(skinId);
      } else {
        selectSkin(SKINS[0].id); // Default
      }

      return true;
    }

    /* ----------------------------------------------------------------
       2. UI LOGIC (Skins)
    ---------------------------------------------------------------- */
    function renderSkins() {
      const carousel = document.getElementById('skinCarousel');
      carousel.innerHTML = '';
      SKINS.forEach(skin => {
        const el = document.createElement('div');
        el.className = 'skin-item';
        el.innerText = skin.name;
        el.onclick = (e) => {
          e.stopPropagation(); // Prevent placement click
          selectSkin(skin.id);
        };
        carousel.appendChild(el);
      });
    }

    function selectSkin(id) {
      const skin = SKINS.find(s => s.id === id) || SKINS[0];
      const personaje = document.querySelector('#personaje');

      // Update Model
      personaje.setAttribute('gltf-model', skin.url);

      // Update UI Highlighting
      document.querySelectorAll('.skin-item').forEach(el => {
        el.classList.remove('selected');
        if (el.innerText === skin.name) el.classList.add('selected');
      });
    }

    /* ----------------------------------------------------------------
       3. CAPTURE LOGIC (Photo & Video)
    ---------------------------------------------------------------- */
    const scene = document.querySelector('a-scene');
    const btnFoto = document.getElementById('btnFoto');
    const btnVideo = document.getElementById('btnVideo');

    // Helper: Send to FlutterFlow / Wrapper
    function sendToApp(type, data) {
      console.log(`Sending ${type}...`);
      const payload = JSON.stringify({ type: type, data: data });

      if (window.FlutterFlow) {
        window.FlutterFlow.postMessage(payload);
      } else if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onCapture', payload);
      } else {
        // Fallback Download
        console.log("No app detected, downloading file.");
        const a = document.createElement('a');
        a.href = data;
        a.download = `capture_${Date.now()}.${type === 'photo' ? 'png' : 'webm'}`;
        a.click();
      }
    }

    // Photo
    btnFoto.addEventListener('click', (e) => {
      e.stopPropagation(); // No hit test

      // We must capture the WebGL canvas. 
      // In WebXR mode, we might need to exit VR to snap high res? 
      // Or just grab current buffer.
      const glCanvas = scene.renderer.domElement;

      // Draw to a temp canvas to merge camera feed if needed (Camera feed is BEHIND canvas in WebXR DOM Overlay)
      // Actually, in WebXR DOM Overlay, the camera is NOT on the canvas. The canvas is transparent.
      // We CANNOT capture the real world camera feed in WebXR security model easily. 
      // We can only capture the virtual content.
      // This is a known limitation of WebXR.
      // FOR ANDROID CHROME: The canvas contains *only* 3D content. 
      // The background is the camera feed handled by the browser. 
      // `glCanvas.toDataURL()` will be transparent with just the character.

      const dataUrl = glCanvas.toDataURL('image/png');
      sendToApp('photo', dataUrl);
    });

    // Video 
    let mediaRecorder;
    let recordedChunks = [];
    let isRecording = false;

    btnVideo.addEventListener('click', (e) => {
      e.stopPropagation();

      if (!isRecording) {
        // Start Recording
        const stream = scene.renderer.domElement.captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp8' });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) recordedChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const reader = new FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = () => {
            sendToApp('video', reader.result);
          };
          recordedChunks = [];
        };

        mediaRecorder.start();
        isRecording = true;
        btnVideo.innerText = "‚èπÔ∏è";
        btnVideo.classList.add('recording');

      } else {
        // Stop Recording
        mediaRecorder.stop();
        isRecording = false;
        btnVideo.innerText = "üî¥";
        btnVideo.classList.remove('recording');
      }
    });

    /* ----------------------------------------------------------------
       INIT
    ---------------------------------------------------------------- */
    renderSkins();
    if (checkSecurity()) {
      console.log("Access Granted");
    }

  </script>
</body>

</html>